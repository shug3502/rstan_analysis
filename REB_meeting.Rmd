---
title: "Meeting with REB"
author: "Jonathan Harrison"
date: "07/09/2018"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=6, fig.height=4,
                      echo=FALSE, warning=FALSE, message=FALSE)
```

# RNA localization
## Big picture

* Developed ODE model for RNA transport and fitted this full model to data to estimate parameters $(a, b, \gamma, \phi, \nu, \sigma)$
* Gained bioloical insight from parameter estimates
* Predictions from fitted model for wild type (WT) behaviour match well
* Predictions from fitted model for overexpression (OE) behaviour agree for nurse cells close to oocyte but disagree for more distant cells

## How can we change the model so that it agrees better for cells further from oocyte?
I have considered alternative models as follows:

* Spatially varying transport bias, $\nu$
* Spatially varying production in OE mutant
* Hierarchical model

Additional suggestion from Richard:
* Perturbations to entries of matrix $B$

## Details to discuss
### Timescales via exponential growth model
Need a precise age for each egg chamber. Can roughly estimate age via developmental time (eg. stage 7) by observing presence of distinctive features. Each stage is a large time window and would prefer a more precise age. By fitting an exponential growth model (independently shown to be a good description at these ages in other work, Jia et al 2016), we can use $\log(A)$, where $A$ is the area of a section through the egg chamber, as a proxy for time.

Do we need a separate exponential growth model for data from different experiments, or for different mutants?

### Assembly/aggregation parameter $\phi$
There is (at least one) structural unidentifiability in the full model (I think?).  

### Identifiability
Tried to assess identifiability of the full model using the symbolic computing capabilities in MATLAB. This involves solving matrix equations involving parameters ($\nu$ and $\gamma$), and was prohibitively slow. Could there be better ways to parameterise the model? Nondimensionalising allows us to remove a parameter, such as transport rate $b$, but to fit to data need to relate to dimensional quantities and dimensional time.  

### Notation for manuscript


### Switch off ring canals
Simulate from a model where we switch off selected ring canals and look at the effect of this on accumulation of RNA (eg. in cells far from the oocyte).
```{r}
library(rstan)
library(broom)
library(dplyr)
identifier = 'testv002'
nSamples=9
nTest=11
nTestOE=9
source('extract_times_and_scaling.R')
times = extract_times_and_scaling(nSamples,nTest,nTestOE)
y0 = rep(1,16); y0[1]=0
stan_file = 'switch_off_RCs.stan'
stan_list = list(y0=y0,
                 T1  = nSamples,                 
                 t0 = times$t0$estimate[3],
                 ts1 = times$ts1,                 
                 a = 9,
                 b = 0.2,
                 gamma = 0.01,
                 nu = 0.95,
                 sigma = 1.25,
                 phi = 0.3,
                 b_i = 3,
                 b_j = 7)
estimates <- stan(file = stan_file,
                  data = stan_list,
                  seed = 42,
                  chains = 4,
                  warmup = 1000,
                  iter = 2000
)
tryCatch({
  #estimates@stanmodel@dso <- new("cxxdso") #seems have to do this to be able to save :S
  saveRDS(estimates, file = paste('fits/switch_off_RCs_',identifier,'.rds',sep='')) # to load use readRDS("fit.rds")
}, warning = function(war) {  
  # warning handler picks up where error was generated
  print(paste("WARNING:  ",war))
}, error = function(err) {  
  # error handler picks up where error was generated
  print(paste("NOT SAVED ERROR:  ",err))
}) # END tryCatch
source('compare_RC_preds.R')
comparison_df <- compare_RC_preds(times$ts1,estimates,identifier)

```

```{r}
expose_stan_functions('switch_off_RCs.stan')
B = construct_matrix(0.95,0)
B_tilde = alter_matrix(B,c(8,16)) #note when this blocks a ring canal this increases the null spcae of the matrix by one
B %>% MASS::Null()
alter_matrix(B,c(3,7)) %>% MASS::Null()

qr(B)
B %>% t() %>% qr %>% qr.Q
B %>% alter_matrix(c(2,4)) %>% t() %>% qr %>% qr.Q

expose_stan_functions('model_comparison_at_stst2.stan')
get_k2(0.5)

k2 = qr.Q(qr(t(B)))[,16]; k2=k2/k2[1]
B 
```

Try out a different version of inference at steady state with blocked ring canals
```{r}
source('run_model_comparison_stst.R')
identifier = 'MCv352'
res <- run_model_comparison_stst(identifier=identifier,use_real_data=TRUE,run_mcmc=FALSE,parametersToPlot = c('nu','xi','phi'),verbose=TRUE,show_diagnostic_plots=TRUE,train_on_OE=TRUE) 
```



## Simple full ODE model: differences between WT and OE
Suppose we take the simple, full ODE model (now parameterised with scaled $\tilde{\gamma} = \gamma/b$) and fit via MCMC to both the WT data and the overexpression data. What does this tell us about the biological model parameters and the differences between these phenotypes?

```{r, echo=TRUE}
source('mrna_transport_full.R')
res_WT = mrna_transport_inference_full('full_nu_uniform_WT_v301',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = FALSE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = FALSE,
						is_nu_uniform = TRUE)

res_OE = mrna_transport_inference_full('full_nu_uniform_OE_v302',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = FALSE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = TRUE,
						is_nu_uniform = TRUE)
```


Try removing decay from the model and comparing with model with decay.

```{r}
source('mrna_transport_full.R')
res_no_decay = mrna_transport_inference_full('no_decay_v303',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = TRUE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = FALSE,
						is_nu_uniform = TRUE, no_decay_model = TRUE)
res_WT = mrna_transport_inference_full('full_nu_uniform_WT_v301',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = TRUE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = FALSE,
						is_nu_uniform = TRUE, no_decay_model = FALSE)

loo::compare(res_WT[[2]], res_no_decay[[2]])
```


Can do the same with the OE data.

```{r}
source('mrna_transport_full.R')
res_no_decay = mrna_transport_inference_full('no_decay_v304',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = TRUE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = TRUE,
						is_nu_uniform = TRUE, no_decay_model = TRUE)
res_OE = mrna_transport_inference_full('full_nu_uniform_OE_v302',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = TRUE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = TRUE,
						is_nu_uniform = TRUE, no_decay_model = FALSE)
loo::compare(res_OE[[2]], res_no_decay[[2]])
```


Results from the hierarchical model without RNA decay. The MCMC has not converged. May need to consider abandoning the hierarchical model. Could try using the posterior for the simpler model as a prior for the hierarchical model. Think that the data driven prior for $\phi$ could be confusing it a little. 
```{r}
source('mrna_transport_full.R')
res_WT = mrna_transport_inference_full('full_nu_uniform_v291',
						use_real_data = TRUE, run_mcmc = FALSE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = FALSE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = TRUE,
						parametersToPlot = c('mu','phi','sigma'),
						use_prior_predictive = FALSE, train_on_OE = FALSE,
						is_nu_uniform = TRUE, no_decay_model = FALSE)
```


Simple ODE model with no decay. Scaling of times determined from the traning data only. Importantly, flat prior for $\phi$ to check for identifiability and see if the data is informative about this.
```{r}
source('mrna_transport_full.R')
res_WT = mrna_transport_inference_full('no_decay_flat_prior_phi_v311',
						use_real_data = TRUE, run_mcmc = TRUE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = FALSE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = FALSE,
						is_nu_uniform = TRUE, no_decay_model = TRUE)
res_OE = mrna_transport_inference_full('no_decay_flat_prior_phi_OE_v312',
						use_real_data = TRUE, run_mcmc = TRUE,
						nSamples = 9, nTest = 11, nTestOE = 9,
						verbose = TRUE, compare_via_loo = FALSE,
						show_diagnostic_plots = TRUE, use_hierarchical_model = FALSE,
						use_prior_predictive = FALSE, train_on_OE = TRUE,
						is_nu_uniform = TRUE, no_decay_model = TRUE)
```

If what we care about is comparing the transport bias, $\nu$, when fitting to WT and OE data, we can do this directly at steady state.

```{r}
source('run_model_comparison_stst.R')
identifier = 'MCv341'
res_wt <- run_model_comparison_stst(identifier=identifier,use_real_data=TRUE,run_mcmc=TRUE,parametersToPlot = c('nu','xi','phi'),verbose=FALSE,show_diagnostic_plots=FALSE,train_on_OE=FALSE)
identifier <- 'MCv342'
res_oe <- run_model_comparison_stst(identifier=identifier,use_real_data=TRUE,run_mcmc=TRUE,parametersToPlot = c('nu','xi','phi'),verbose=FALSE,show_diagnostic_plots=FALSE,train_on_OE=TRUE)
```


So interestingly fitting at steady state gives high transport bias in the OE similar to the WT rather than a different value, but much higher noise. It may be that in this case, the predictions are almost entirely explained by the noise. 

We have a mechanistic hypothesis about what is causing the noise in this case (blocking). It would be great to be able to include this more mechanistic measurement noise model, rather than simply a Gaussian which is not realistic in this context. However, this seems tricky to do.

In the meantime, plot this RNA distributions for WT and OE
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
source('extract_times_and_scaling.R')
times = extract_times_and_scaling(9,11,9)
my_normaliser <- function(dataset) apply(dataset,1,function(x)x/x[1]) %>% t()
  data = matrix(as.numeric(read.csv('data/exp_data.csv',sep=',',header=FALSE,stringsAsFactors = FALSE)),ncol=16,byrow=TRUE)
  raw_data = data[times$sort_indices1,] #need to sort time series and correspondingly reorder rows
  exp_data = raw_data
  exp_data[is.na(exp_data)]=0 #stan can't deal with NAs
  overexpression_data = matrix(as.numeric(read.csv('data/exp_data_overexpression.csv',sep=',',header=FALSE,stringsAsFactors = FALSE)),ncol=16,byrow=TRUE)
  overexpression_data = overexpression_data[times$sort_indices4,] #need to sort time series and correspondingly reorder rows
  test_data = rbind(data,overexpression_data)
  test_data = test_data[times$sort_indices2,]
  test_data[is.na(test_data)]=0
 
  normalised_data = exp_data %>% my_normaliser #divide by amount in oocyte to normalise for stst
colnames(normalised_data) = seq_len(16)
df_wt <- as.data.frame(normalised_data) %>% mutate(time=times$ts1) %>% gather(key=cell,value=rna,-time) %>% mutate(phenotype='WT',cell=as.integer(cell))

   swap <- function(name1, name2, envir = parent.env(environment()))
    {
      temp <- get(name1, pos = envir)
      assign(name1, get(name2, pos = envir), pos = envir)
      assign(name2, temp, pos = envir)
    }
    swap('exp_data','overexpression_data')
    temp <- list(times$ts1,times$ts4)
    times$ts1 <- temp[[2]]
    times$ts4 <- temp[[1]]
    print('swapped')
    print(times$ts1)

normalised_data = exp_data %>% my_normaliser #divide by amount in oocyte to normalise
colnames(normalised_data) = seq_len(16)
df_oe <- as.data.frame(normalised_data) %>% mutate(time=times$ts4) %>% gather(key=cell,value=rna,-time) %>% mutate(phenotype='OE',cell=as.integer(cell))  
full_join(df_wt,df_oe) %>%
  ggplot(aes(x=cell,y=rna,group=time)) +
  geom_line() +
  facet_grid(~phenotype)


```




